<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Charming with Claude - Updates</title>
    <link>https://github.com/tonyandrewmeyer/charming-with-claude</link>
    <description>Updates from the Charming with Claude repository: new experiments and reading list additions</description>
    <atom:link href="https://tonyandrewmeyer.github.io/charming-with-claude/feed.rss" rel="self" type="application/rss+xml"/>
    <item>
      <title>Reading List Update: docs: add link to &quot; Using LLMs at Oxide&quot;, a great set of high-level guidelines.</title>
      <link>https://github.com/tonyandrewmeyer/charming-with-claude/commit/759992f48ab94da53f1ad53615018345ef90eb08</link>
      <description>docs: add link to &quot; Using LLMs at Oxide&quot;, a great set of high-level guidelines.</description>
      <content:encoded><![CDATA[<pre>diff --git a/READTHEM.md b/READTHEM.md
index 60653a6..824e8c6 100644
--- a/READTHEM.md
+++ b/READTHEM.md
@@ -24,4 +24,5 @@
 * [Picking the right sandbox](https://www.luiscardoso.dev/blog/sandboxes-for-ai) - very detailed overview of (local) sandbox choices for use with AI (but really any untrusted code)
 * [Don&apos;t fall into the anti-AI hype](https://antirez.com/news/158) - positive and reflective
 * [How to Code Claude Code in 200 Lines of Code](https://www.mihaileric.com/The-Emperor-Has-No-Clothes/) - an exaggeration of course, but it shows how coding agents are fairly simple at heart
- 
\ No newline at end of file
+* [
+Using LLMs at Oxide](https://rfd.shared.oxide.computer/rfd/0576) - a great set of guidelines for using LLMs: responsibility, rigour, empathy, teamwork, urgency, &quot;use must always be consistent with our deeply-held sense of responsibility: our responsibility to our product, our responsibility to our customers — and our responsibility to one another&quot;.
\ No newline at end of file
</pre>]]></content:encoded>
      <dc:creator>Tony Meyer</dc:creator>
      <pubDate>Sat, 07 Feb 2026 00:18:40 +1300</pubDate>
      <guid isPermaLink="false">readthem-759992f48ab94da53f1ad53615018345ef90eb08</guid>
    </item>
    <item>
      <title>Reading List Update: docs: link to &quot;How to Code Claude Code&quot; article</title>
      <link>https://github.com/tonyandrewmeyer/charming-with-claude/commit/a00fe9ce54ca9182aebe6d4562fa97930d963555</link>
      <description>docs: link to &quot;How to Code Claude Code&quot; article</description>
      <content:encoded><![CDATA[<pre>diff --git a/READTHEM.md b/READTHEM.md
index e9f839d..60653a6 100644
--- a/READTHEM.md
+++ b/READTHEM.md
@@ -23,3 +23,5 @@
 * [A pragmatic guide to LLM evals for devs](https://newsletter.pragmaticengineer.com/p/evals)
 * [Picking the right sandbox](https://www.luiscardoso.dev/blog/sandboxes-for-ai) - very detailed overview of (local) sandbox choices for use with AI (but really any untrusted code)
 * [Don&apos;t fall into the anti-AI hype](https://antirez.com/news/158) - positive and reflective
+* [How to Code Claude Code in 200 Lines of Code](https://www.mihaileric.com/The-Emperor-Has-No-Clothes/) - an exaggeration of course, but it shows how coding agents are fairly simple at heart
+ 
\ No newline at end of file
</pre>]]></content:encoded>
      <dc:creator>Tony Meyer</dc:creator>
      <pubDate>Fri, 06 Feb 2026 14:30:00 +1300</pubDate>
      <guid isPermaLink="false">readthem-a00fe9ce54ca9182aebe6d4562fa97930d963555</guid>
    </item>
    <item>
      <title>New Experiment: Sungather K8S Operator</title>
      <link>https://github.com/tonyandrewmeyer/charming-with-claude/tree/main/experiments/2025-12-28-sungather-k8s-operator</link>
      <description>New experiment: sungather k8s operator</description>
      <content:encoded><![CDATA[<h1>sungather-k8s-operator</h1>
<p>In this experiment, I had Claude Code build a Kubernetes charm for <a href="https://sungather.net">SunGather</a>, a data collection tool for Sungrow solar inverters. The application collects operational data via ModBus connections and exports it to MQTT, InfluxDB, PVOutput.org, and a built-in web interface.</p>
<p>(I have a Sungrow inverter and would like better access to the data than the app provides).</p>
<h2>Goals</h2>
<ul>
<li>Continue iterating on the charm development process from the <a href="../2025-12-23-beszel-k8s-operator/">beszel experiment</a>.</li>
<li>Test the new <strong>skills</strong> that were created for <code>charmcraft</code>, <code>jhack</code>, and <code>concierge</code>.</li>
<li>Continue to improve integration testing, but not particularly with spread in this case.</li>
</ul>
<p>This was not an original goal, but along the way I also added a goal of building a Rock (from necessity, but it's another interesting, charming adjacent, task).</p>
<h2>Setup</h2>
<p>As with the beszel experiment, Claude ran in YOLO mode (<code>--dangerously-skip-permissions</code>) inside a <a href="https://canonical.com/multipass">Multipass</a> virtual machine with <a href="https://github.com/canonical/concierge">Concierge</a> providing a fully bootstrapped Juju environment (<code>concierge prepare -p dev</code>).</p>
<h3>Skills</h3>
<p>This experiment introduced three new <strong>skills</strong> for Claude Code:</p>
<table>
<thead>
<tr>
<th>Skill</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>charmcraft</strong></td>
<td>Expert guidance for building, testing, and publishing charms</td>
</tr>
<tr>
<td><strong>jhack</strong></td>
<td>Utilities for debugging charms, inspecting relations, and rapid iteration</td>
</tr>
<tr>
<td><strong>concierge</strong></td>
<td>Environment provisioning for charm development</td>
</tr>
</tbody>
</table>
<p>Each skill includes:
- A <code>SKILL.md</code> file with comprehensive command references
- Reference documentation for configuration and troubleshooting
- Example workflows and best practices</p>
<p>The skills were installed in <code>.claude/skills/</code> within the experiment directory. See <a href="https://github.com/tonyandrewmeyer/sungather-k8s-operator/blob/main/INSTALL-SKILLS.md">INSTALL-SKILLS.md</a> in the repository for installation instructions.</p>
<p>Once again, the skills seem to have been ignored. I've done a little more research and maybe I have to tell Claude about them explicitly, even though they are located where the tool should expect them.</p>
<h3>CLAUDE.md Updates</h3>
<p>The <code>CLAUDE.md</code> file was largely unchanged from the <code>beszel</code> experiment, maintaining the same guidance about:
- Using <code>ops.testing</code> (not Harness) for unit tests
- Using Jubilant (not pytest-operator) for integration tests
- Following the "testing sandwich" pattern
- Code style guidelines (British English, type hints, etc.)</p>
<h2>Results</h2>
<p>The <a href="https://tonyandrewmeyer.github.io/sungather-k8s-operator/">full transcripts</a> are available, made pretty by <a href="https://simonwillison.net/2025/Dec/25/claude-code-transcripts/">Simon Willison's claude-code-transcripts tool</a>. The final result is in the <a href="https://github.com/tonyandrewmeyer/sungather-k8s-operator">sungather-k8s-operator repository</a>.</p>
<h3>What Was Built</h3>
<pre><code>sungather-k8s-operator/
├── src/
│   ├── charm.py          # Main charm with config/action dataclasses
│   └── sungather.py      # Workload interaction module
├── tests/
│   ├── unit/             # 13 ops.testing unit tests
│   └── integration/
│       ├── test_charm.py           # 11 Jubilant integration tests
│       ├── test_charm_with_mock.py # 9 mock server tests
│       └── mock_sungrow/           # Mock inverter server
├── rock/                 # Custom OCI image definition
├── .github/workflows/    # CI/CD with rock building
└── [documentation files]
</code></pre>
<p><strong>Key statistics:</strong>
- <strong>50 commits</strong> over multiple sessions
- <strong>25 configuration options</strong> covering inverter, MQTT, InfluxDB, PVOutput, and webserver settings
- <strong>3 actions</strong>: <code>run-once</code>, <code>test-connection</code>, <code>get-inverter-info</code>
- <strong>Traefik ingress integration</strong> for web UI access</p>
<p>The actions come directly from what the workload offers, but better charm design for the actual desired purpose would have had different ones.</p>
<h3>The Charm Plan</h3>
<p>Claude produced a comprehensive <a href="https://github.com/tonyandrewmeyer/sungather-k8s-operator/blob/main/CHARM_PLAN.md">CHARM_PLAN.md</a> covering:
- Why Kubernetes was chosen over machine charm
- Configuration options with justifications
- Secrets management for credentials
- Integration strategy (ingress, MQTT)
- Implementation phases
- Edge cases and testing strategy</p>
<p>This level of upfront planning, guided by the CLAUDE.md instructions to "ultrathink about a plan", produced a much more coherent architecture than simply diving into code.</p>
<h2>Lessons</h2>
<h3>The Broken OCI Image Problem</h3>
<p>The default upstream image (<code>bohdans/sungather:latest</code>) was broken - missing the <code>SungrowClient</code> Python module. I didn't know about this in advance - I had run the utility as a Python script, but not attempted to use the image.</p>
<p>Claude's solution was to build a custom Rock:</p>
<pre><code class="language-bash">cd rock
rockcraft pack
# Produces sungather_0.3.8_amd64.rock (89MB)
</code></pre>
<p>The rock uses <code>uv</code> for dependency installation (~23ms) and includes all 20 required Python packages. This added significant complexity but demonstrates handling real-world workload issues.</p>
<h3>Mock Server for Integration Testing</h3>
<p>Although I was able to test the charm against my actual inverter, that's obviously not available in CI. An additional challenge was to create a mock Sungrow inverter server for integration testing:</p>
<pre><code>tests/integration/mock_sungrow/
├── registers.py      # Simulated register map (100+ registers)
├── modbus_server.py  # Modbus TCP on port 5020
├── http_server.py    # HTTP/WebSocket (WiNet-S) on port 8082
└── server.py         # Orchestration
</code></pre>
<p>This enables testing without physical hardware - realistic data, both protocols supported, pytest fixture integration. The mock server was verified working locally, though the full integration tests require pushing the rock to an accessible registry.</p>
<p>This worked quite well - I had to tighten the focus to match the physical setup I have, which is what I care about most, but this was overall a painless and very fast addition. I haven't really verified it outside of the tests, so it's possible it's also quite flawed, of course!</p>
<h3>CI/CD Required Significant Debugging</h3>
<p>The CI pipeline required <strong>7 iterative fixes</strong>:</p>
<ol>
<li>LXD permission errors → <code>--destructive-mode</code></li>
<li>File permissions → <code>sudo</code> with ownership correction</li>
<li>Ubuntu version mismatch → Changed to <code>ubuntu-22.04</code> runner</li>
<li>Docker image tagging → Extract image ID from <code>docker load</code></li>
<li>Invalid charmcraft flag → Removed unsupported <code>--resource</code></li>
<li>Charmcraft LXD issues → Applied <code>--destructive-mode</code></li>
<li>Integration test environment → Same Ubuntu version fix</li>
</ol>
<p>Each failure required Claude to analyse logs, understand the root cause, and propose fixes. This iterative debugging loop worked well, though it consumed significant context. Ideally, better instructions, templates, or skills would avoid needing this much work.</p>
<h3>Jubilant Integration Tests</h3>
<p>The integration tests used <a href="https://documentation.ubuntu.com/jubilant/">Jubilant</a> correctly this time:</p>
<pre><code class="language-python">def test_deploy_with_config(juju: jubilant.Juju) -&gt; None:
    juju.deploy(
        str(CHARM_PATH),
        config={&quot;inverter-host&quot;: &quot;192.168.1.100&quot;},
        resources={&quot;sungather-image&quot;: WORKING_IMAGE},
    )
    juju.wait(apps=[&quot;sungather-k8s&quot;], status=&quot;blocked&quot;)
    # Assert on expected blocked status (no real inverter)
</code></pre>
<p>This is a significant improvement from the imagined Jubilant APIs in previous experiments.</p>
<h3>Path and Environment Issues</h3>
<p>A debugging session was needed to fix workload startup:
- Incorrect file paths in charm code
- Broken virtualenv symlinks in the container
- Missing working directory specifications</p>
<p>The solution involved switching from a virtualenv to system Python and adding explicit working directory parameters to Pebble exec calls.</p>
<h2>What Worked Well</h2>
<table>
<thead>
<tr>
<th>Area</th>
<th>Observation</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Plan mode</strong></td>
<td>Comprehensive planning before implementation</td>
</tr>
<tr>
<td><strong>Testing sandwich</strong></td>
<td>Integration tests first, then implementation, then unit tests</td>
</tr>
<tr>
<td><strong>Rock building</strong></td>
<td>Successfully resolved broken upstream image</td>
</tr>
<tr>
<td><strong>Mock server</strong></td>
<td>Test infrastructure</td>
</tr>
<tr>
<td><strong>CI debugging</strong></td>
<td>Systematic approach to fixing pipeline issues</td>
</tr>
<tr>
<td><strong>Documentation</strong></td>
<td>README, TUTORIAL, CONTRIBUTING, SECURITY all created</td>
</tr>
</tbody>
</table>
<h2>What Needs Improvement</h2>
<table>
<thead>
<tr>
<th>Area</th>
<th>Observation</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Skills usage</strong></td>
<td><!-- TODO: Add observations about whether skills were actively used --></td>
</tr>
<tr>
<td><strong>CI iteration time</strong></td>
<td>Each fix required a full CI run to verify</td>
</tr>
<tr>
<td><strong>Registry complexity</strong></td>
<td>Getting rocks into K8s clusters remains fiddly</td>
</tr>
</tbody>
</table>
<h2>Comparison with Previous Experiments</h2>
<pre><code class="language-mermaid">graph LR
    subgraph mosquitto[&quot;Mosquitto (Aug 2025)&quot;]
        m1[Machine charm]
        m2[No working tests]
        m3[Basic structure]
    end

    subgraph beszel[&quot;Beszel (Dec 2025)&quot;]
        b1[K8s charm]
        b2[Working tests]
        b3[Spread challenges]
    end

    subgraph sungather[&quot;SunGather (Dec 2025)&quot;]
        s1[K8s charm]
        s2[Mock server tests]
        s3[Rock building]
        s4[Additional skills introduced]
    end

    mosquitto --&gt; beszel --&gt; sungather
</code></pre>
<p>The progression shows:
- <strong>Mosquitto</strong>: Foundation, identified many issues
- <strong>Beszel</strong>: Working K8s charm, struggled with spread
- <strong>SunGather</strong>: Most complete, handled real-world OCI issues, introduced skills</p>
<h2>Files of Interest</h2>
<ul>
<li><a href="https://github.com/tonyandrewmeyer/sungather-k8s-operator/blob/main/CHARM_PLAN.md">CHARM_PLAN.md</a> - Comprehensive architecture planning</li>
<li><a href="https://github.com/tonyandrewmeyer/sungather-k8s-operator/blob/main/TESTING_SUMMARY.md">TESTING_SUMMARY.md</a> - Mock server implementation details</li>
<li><a href="https://github.com/tonyandrewmeyer/sungather-k8s-operator/blob/main/MOCK_SERVER_SUMMARY.md">MOCK_SERVER_SUMMARY.md</a> - Test infrastructure documentation</li>
<li><a href="https://github.com/tonyandrewmeyer/sungather-k8s-operator/tree/main/rock">rock/rockcraft.yaml</a> - Custom OCI image definition</li>
</ul>
<h2>Final Thoughts</h2>
<p>I need to either figure out how to get skills to be used, or give up on them. The testing side is also still taking way too long. Creating a rock was a nice addition - it might be nice to start with that as a goal next time. Getting the rock into a registry was more complex than it should have been, and something I would have expected the tool to already be familiar with.</p>
<p>It would be interesting to start with <code>uv</code> installed and <code>uv tool install tox --with=tox-uv</code> but without <code>concierge</code> to see how well Claude handles that.</p>
<p>It's also be interesting to build the same charm with two tools (Claude and something else), ideally using the same model, to see if there's much variation in the output.</p>]]></content:encoded>
      <dc:creator>Tony Meyer</dc:creator>
      <pubDate>Mon, 02 Feb 2026 08:09:41 +1300</pubDate>
      <guid isPermaLink="false">experiment-2025-12-28-sungather-k8s-operator</guid>
    </item>
    <item>
      <title>New Experiment: Beszel K8S Operator</title>
      <link>https://github.com/tonyandrewmeyer/charming-with-claude/tree/main/experiments/2025-12-23-beszel-k8s-operator</link>
      <description>New experiment: beszel k8s operator</description>
      <content:encoded><![CDATA[<h1>beszel-k8s-operator</h1>
<p>In this experiment, I had Claude Code build a charm for <a href="https://www.beszel.dev">beszel</a>, a simple monitoring utility.</p>
<h2>Goals</h2>
<ul>
<li>Determine how much Claude has progressed since the earlier <a href="../2025-08-01-mosquitto-operator/">mosquitto experiment</a>.</li>
<li>Develop a Kubernetes charm, rather than a machine one.</li>
<li>Run Claude in YOLO mode (<code>--dangerously-skip-permissions</code>) inside of a <a href="https://canonical.com/multipass">Multipass</a> virtual machine. It seems like this is the best way to run Claude Code for anything other than trivial work.</li>
<li>To see how much could be accomplished with minimal input - basically give an initial, very basic, instruction to build the charm (I literally gave it only <code>Build a charm for beszel. https://www.beszel.dev/</code>) and see how far Claude could get without help.</li>
</ul>
<h2>Setup</h2>
<p>Inside of the VM, I installed Claude Code itself, and also <a href="https://github.com/canonical/concierge">Concierge</a>, and ran <code>sudo concierge prepare -p dev</code> so that Claude was starting with a completely bootstrapped Juju (with both K8s and machine controllers).</p>
<p>The <a href="./CLAUDE.md">CLAUDE.md</a> file had a few updates from the one used with the <code>mosquitto</code> experiment.</p>
<pre><code class="language-diff">5,6d4
&lt; Note that to run `charmcraft` on macOS, you will need to run `uvx charmcraft`.
&lt; 
9c7
&lt; We are building a *charm* to be deployed on a *Juju* controller. All the information you need about Juju can be found at https://juju.is/docs
---
&gt; We are building a *charm* to be deployed on a *Juju* controller. All the information you need about Juju can be found at https://documentation.ubuntu.com/juju/latest/
28c26
&lt; * State transition tests, which we refer to as unit tests. These use [ops.testing](https://documentation.ubuntu.com/ops/latest/reference/ops-testing.html). Each test prepares by creating an `testing.Context` object and a `testing.State` object that describes the Juju state when the event is run, then acts by using `ctx.run` to run an event, then asserts on the output state, which is returned by `ctx.run`.
---
&gt; * State transition tests, which we refer to as unit tests. These use [ops.testing](https://documentation.ubuntu.com/ops/latest/reference/ops-testing.html)'s `Context` and `State`, **not Harness**. Each test prepares by creating an `testing.Context` object and a `testing.State` object that describes the Juju state when the event is run, then acts by using `ctx.run` to run an event, then asserts on the output state, which is returned by `ctx.run`.
38c36
&lt; Integration tests can be run with `tox -e integration`, but also with `charmcraft test`.
---
&gt; Integration tests can be run with `tox -e integration`.
54c52
&lt; At this point, you should ultrathink about a plan for the charm. Use the research from the first step and plan what config, actions, storage, resources, secrets, and so on it should use, and how it will scale and interact with other charms. Do *not* start implementing the charm until you have confirmed that the plan is acceptable. You'll want to document this plan in a markdown file so that it can be referred to later.
---
&gt; At this point, you should ultrathink about a plan for the charm. Use the research from the first step and plan what config, actions, storage, resources, secrets, and so on it should use, and how it will scale and interact with other charms. Do *not* start implementing the charm until you have confirmed that the plan is acceptable. You'll want to document this plan in a markdown file so that it can be referred to later. Update this file (CLAUDE.md) to include specifics about the charm being developed, rather than a generic set of instructions for building a charm.
96a95,96
&gt; * Comments are for explaining *why* a decision was made, not *what* the code is doing. If a reader cannot understand *what* the code is doing, it probably needs to be simplified.
&gt; * Don't use `type: ignore` unless there is no other reasonable option.
</code></pre>
<p>Key Changes</p>
<ul>
<li>Tooling &amp; Commands: Removed the specific instruction to run charmcraft via uvx on macOS and removed charmcraft test as a suggested way to run integration tests, leaving tox -e integration as the primary method. (Because I moved off macOS to Ubuntu).</li>
<li>Documentation Links: Updated the Juju documentation URL from the legacy juju.is domain to the new documentation.ubuntu.com path.</li>
<li>Testing Guidance: Explicitly clarified that unit tests should use ops.testing's Context and State patterns rather than the older Harness method.</li>
<li>Process Updates: Added a requirement to update the CLAUDE.md file with project-specific details during the planning phase, rather than keeping it as a template of generic instructions.</li>
<li>Coding Standards: Introduced two new "Best Practice" rules:</li>
<li>Comments should explain why, not what (favouring self-documenting code).</li>
<li>The use of # type: ignore is discouraged unless absolutely necessary.</li>
</ul>
<p>I also added a few subagents, based on the <a href="https://github.blog/ai-and-ml/github-copilot/how-to-write-a-great-agents-md-lessons-from-over-2500-repositories/">GitHub recommendations</a>, and two skills, one <a href="https://github.com/mitsuhiko/agent-stuff/tree/main/skills/tmux">Armin's tmux skill</a> and a custom Juju skill.</p>
<p>There was also an initial <code>settings.json</code>, but this mostly has some initial permissions approval, and since I was running with permission-checking off, this probably did little to help, if anything. It did have setup for auto-formatting Python code, but something was wrong and that continually failed, which confused Claude, and it couldn't fix it itself.</p>
<h2>Results</h2>
<p>The <a href="https://tonyandrewmeyer.github.io/beszel-k8s-operator/">full transcript</a> is available, made pretty by <a href="https://simonwillison.net/2025/Dec/25/claude-code-transcripts/">Simon Willison's claude-code-transcripts tool</a>. It includes links to the commits that Claude did as it worked. The final result is available in the <a href="https://github.com/tonyandrewmeyer/beszel-k8s-operator">beszel-k8s-operator repository</a>.</p>
<h2>Lessons</h2>
<h3>Plan mode</h3>
<p>Plan mode existed in Claude Code in the last experiment, but has been significantly upgraded since then. The first steps Claude took were the "research your workload" and "design the charm" ones, and did this in plan mode. I was then presented with options for the development, which I mostly accepted as-is. I did point out that there was a local <code>juju</code> and that Claude was in a sandbox.</p>
<h3><code>charmcraft init</code></h3>
<p>Claude correctly used Charmcraft to get an initial charm state, and I feel this did a good job of getting this going well. It did need to 'figure out' that <code>--force</code> was needed, since the agent instruction files were already present. That should probably be in the instructions.</p>
<h3>Starting with integration tests</h3>
<p>Claude paid attention to the instructions to start with integration tests. These weren't terrible: they use <a href="https://documentation.ubuntu.com/jubilant/">Jubilant</a> and get parts correct (most noticeably running actions and ssh commands are wrong).</p>
<h3>Code of Conduct</h3>
<p>Claude still seems to get stuck trying to create a code of conduct file, so I again interrupted things here and told it to skip that step. This likely needs to either become part of the Charmcraft profile, or get removed as an instruction from CLAUDE.md. Interestingly, the transcript shows it can download the template, it just can't create the file itself with that content.</p>
<h3>Trust</h3>
<p>Charms requiring <code>--trust</code> is so common that Claude did it here, without even needing it. It would be great to try to reduce that.</p>
<h3><code>tox-uv</code> is the default but unintuitive</h3>
<p>Charmcraft installs <code>tox.ini</code> in a way that requires installing <a href="https://tox.wiki/en/4.32.0/">tox</a> with <a href="https://pypi.org/project/tox-uv/">tox-uv</a>. This is not obvious, and Claude missed it and this meant it didn't run the commands as often as it should, or benefit from the tooling being set up (I eventually did the install myself). This is also a challenge when setting up the CI.</p>
<p>We should improve this somehow, without waiting for <code>uv</code> to add a task runner system.</p>
<h3>Juju skill ignored</h3>
<p>There were several interactions with Juju, as expected, including adding a model. The skill was ignored, as far as I can tell. I do not know why this is, but need to figure it out before investing any more time into skills.</p>
<h3>CI is configured but not tested</h3>
<p>I had to help considerably with this. I wonder if I told Claude the repository address (it could get it from <code>git remote</code> but that wasn't in place at the very start) if it would do better, or maybe some instructions about how to check this (with <a href="https://cli.github.com">gh</a>, probably, or maybe <a href="https://nedbatchelder.com/blog/202303/watchgha.html">Ned Batchelder's watchgha</a>) would encourage Claude to verify that it was correct.</p>
<p>It also installed Charmcraft to pack the charm, but didn't install or bootstrap Juju, and I helped explain what to do. I wonder if having this set up initially didn't help, because there was an assumption the CI environment would be similar to the dev one.</p>
<h3>Claude is better with slow tasks</h3>
<p>In the previous experiment, Claude struggled with tasks (like packing and integration tests) that were very slow (over 10 minutes). Since then, Claude has gained the ability to work with background tasks and handle long-running work much more smoothly, and I didn't see any issues with that this time.</p>
<h3>Integrations</h3>
<p>Claude did a reasonable job of integrations (for identity, for S3, for ingress). I feel like some documentation pointing to <a href="https://documentation.ubuntu.com/charmlibs">charmlibs</a> including how to use libraries, what libraries are available, and so on, might work better than the web searches that land on Charmhub.</p>
<h3>Minimal containers</h3>
<p>The (upstream) Beszel container uses a <a href="https://hub.docker.com/_/scratch">scratch image</a>, so there's no shell in the workload container (and also no tools like <code>curl</code>, which Claude tried to use). A <a href="https://documentation.ubuntu.com/rockcraft/latest/explanation/chisel/#explanation-chisel">chiselled Rock</a> would have similar issues.</p>
<p>It might be worth giving Claude instructions or even a skill to deal with this. Perhaps even with <a href="https://github.com/tonyandrewmeyer/cascade">Cascade</a>!</p>
<h3>Unit tests</h3>
<p>These were immediately Scenario tests, but Scenario 6 from the look of it. I think the "use scenario via ops.testing" decision was a terrible one for agents, although it should resolve itself over time. The agent struggled pulling usage documentation and examples, so more of that would be good (we have plenty already, so just helping it know what to fetch).</p>
<h2>Spread</h2>
<p>At this point, we're a bit over a third of the way down page eight of the first transcript. I then asked Claude to use <a href="https://github.com/canonical/spread">spread</a> for the integration tests, since this is what Charms should do now, and since there is better scaffolding in Charmcraft now (which I installed for Claude at this point). This stage seemed to take forever... (there are 7 more pages of transcript, so it's about half of the effort).</p>
<p>Partly this is because I couldn't guide Claude the right way, and partly this is because this is new, and partly this is because our documentation is terrible (mostly: missing). It will be interesting to use Claude to try out the new documentation later this cycle.</p>
<h2>Final notes</h2>
<p>It's taken me a month to write this up properly (I did a bit earlier, but to finish). I need to figure out how to do that more promptly and concisely and efficiently.</p>
<p>I felt this went vastly better than the last experiment, right up until spread. Some of the issues were also my fault (the bad tool config). I'm looking forward to trying more out, and also seeing if I can get skills working usefully.</p>]]></content:encoded>
      <dc:creator>Tony Meyer</dc:creator>
      <pubDate>Sun, 01 Feb 2026 19:42:40 +1300</pubDate>
      <guid isPermaLink="false">experiment-2025-12-23-beszel-k8s-operator</guid>
    </item>
    <item>
      <title>Reading List Update: docs: add a link to &quot;Don&apos;t fall into the anti-AI hype&quot;</title>
      <link>https://github.com/tonyandrewmeyer/charming-with-claude/commit/79b6c637b5aaf9e024407c8c45fa4dd8b6cbb8e7</link>
      <description>docs: add a link to &quot;Don&apos;t fall into the anti-AI hype&quot;</description>
      <content:encoded><![CDATA[<pre>diff --git a/READTHEM.md b/READTHEM.md
index eabf994..e9f839d 100644
--- a/READTHEM.md
+++ b/READTHEM.md
@@ -19,6 +19,7 @@
 * [Safe YOLO mode for Claude](https://www.anthropic.com/engineering/claude-code-best-practices#d-safe-yolo-mode) - the Docker Dev Containers example in particular
 * [LLMs as Parts of Systems](https://brooker.co.za/blog/2025/08/12/llms-as-components.html) - from one of the [Kiro](https://kiro.dev/) engineers
 * [The fate of “small” open source](https://nolanlawson.com/2025/11/16/the-fate-of-small-open-source/) - the author argues that there is educational value in the zillion tiny library issue, which AI may solve
-* [Just Talk To It - the no-bs Way of Agentic Engineering](https://steipete.me/posts/just-talk-to-it) - Will date quickly, but a good summary of the world in October 2025
+* [Just Talk To It - the no-bs Way of Agentic Engineering](https://steipete.me/posts/just-talk-to-it) - will date quickly, but a good summary of the world in October 2025
 * [A pragmatic guide to LLM evals for devs](https://newsletter.pragmaticengineer.com/p/evals)
-* [Picking the right sandbox](https://www.luiscardoso.dev/blog/sandboxes-for-ai)
+* [Picking the right sandbox](https://www.luiscardoso.dev/blog/sandboxes-for-ai) - very detailed overview of (local) sandbox choices for use with AI (but really any untrusted code)
+* [Don&apos;t fall into the anti-AI hype](https://antirez.com/news/158) - positive and reflective
</pre>]]></content:encoded>
      <dc:creator>Tony Meyer</dc:creator>
      <pubDate>Mon, 12 Jan 2026 14:07:20 +1300</pubDate>
      <guid isPermaLink="false">readthem-79b6c637b5aaf9e024407c8c45fa4dd8b6cbb8e7</guid>
    </item>
    <item>
      <title>Reading List Update: docs: Add link to an article outlining differences between sandbox types</title>
      <link>https://github.com/tonyandrewmeyer/charming-with-claude/commit/e89a8276fdfd3897828c3b15d157c78d74603198</link>
      <description>docs: Add link to an article outlining differences between sandbox types</description>
      <content:encoded><![CDATA[<pre>diff --git a/READTHEM.md b/READTHEM.md
index 986b171..eabf994 100644
--- a/READTHEM.md
+++ b/READTHEM.md
@@ -21,3 +21,4 @@
 * [The fate of “small” open source](https://nolanlawson.com/2025/11/16/the-fate-of-small-open-source/) - the author argues that there is educational value in the zillion tiny library issue, which AI may solve
 * [Just Talk To It - the no-bs Way of Agentic Engineering](https://steipete.me/posts/just-talk-to-it) - Will date quickly, but a good summary of the world in October 2025
 * [A pragmatic guide to LLM evals for devs](https://newsletter.pragmaticengineer.com/p/evals)
+* [Picking the right sandbox](https://www.luiscardoso.dev/blog/sandboxes-for-ai)
</pre>]]></content:encoded>
      <dc:creator>Tony Meyer</dc:creator>
      <pubDate>Sun, 11 Jan 2026 15:37:02 +1300</pubDate>
      <guid isPermaLink="false">readthem-e89a8276fdfd3897828c3b15d157c78d74603198</guid>
    </item>
    <item>
      <title>New Experiment: Mosquitto Operator</title>
      <link>https://github.com/tonyandrewmeyer/charming-with-claude/tree/main/experiments/2025-08-01-mosquitto-operator</link>
      <description>New experiment: mosquitto operator</description>
      <content:encoded><![CDATA[<p>I have plenty of concerns about the current genAI boom / bubble -- my favourite presentation that I've given over the last couple of years was all about the negatives of (generative / LLM) AI and why organisations should think carefully ("ultrathink" ;)) before incorporating it.</p>
<p>It's clear that there are financial issues, and there are lots of unanswered questions about sustainability and the environment, and both legal and moral questions about training data. I very strongly feel that the world will be a lesser place if we move to consuming creative content (movies, music, books, and all the rest) that's produced without significant human input. However, it does seem like that there is some value in using these tools to code.</p>
<p>You should definitely read <a href="https://www.wheresyoured.at/">Ed Zitron</a>, but read <a href="https://simonwillison.net/">Simon</a> and <a href="https://lucumr.pocoo.org/">Armin</a> and <a href="https://fly.io/blog/youre-all-nuts/">Thomas Ptacek</a> and others as well. Given that I'm employed as a software engineer, I don't think that I can simply be <a href="https://paddy.carvers.com/posts/2025/07/ai/">tired of talking about AI</a>, even though sometimes I really am. Use it or not, love it or not, bubble or not, I have a responsibility to know what's going on.</p>
<p>I'm curious how useful "agentic" tools, like Claude Code, are when creating charms. I'm sure that they are not anywhere near being able to create charms of the complexity and quality that our charming teams regularly produce. I'm also fairly sure that for simple charms that are providing workloads using common web frameworks that the Platform Engineering team are already providing what's needed with the <a href="https://canonical-charmcraft.readthedocs-hosted.com/3.5.2/tutorial/#factor-app-extensions">12-factor project</a>.</p>
<p>I wondered how capable these tools are at producing at least an initial charm for a fairly simple workload that isn't a web app. A 'success' in my experimentation wouldn't be to produce something that's ready to be used in production or publicly listed on Charmhub, but be substantially closer to that than a basic <code>charmcraft init</code>, that doesn't require rewriting a large number of files. Good for a prototype or proof-of-concept or a starting point for building a quality charm.</p>
<p>(This is roughly what is being called <a href="https://maggieappleton.com/2025-08-vibe-legacy-code">vibe coding</a>, although there are <a href="https://simonwillison.net/2025/Mar/19/vibe-coding/">differing definitions still</a>. Vibe code is <a href="https://blog.val.town/vibe-code">legacy code</a>, and <a href="https://leaddev.com/software-quality/how-ai-generated-code-accelerates-technical-debt">immediately technical debt</a>).</p>
<p>As charming is increasingly adopted outside of Canonical, I'm sure that there is going to be a lot of genAI produced code involved, and I'd like to understand how we (Charm Tech in particular) can make that a better experience for these new charmers, getting them to a reasonable start without needing to know a lot of code, and bringing them into the charming world, where they'll be able to build their skills to eventually produce charms of much higher quality.</p>
<p>I'm hopeful that if we make charming easier for AI agents then we'll also be making it easier for humans, too, since one of the interesting aspects of this round of AI is that it's built on top of all the writing that we did for humans. In the same way, I think it's interesting to see where AI agents fail or struggle when writing charms, because these might be places that new charmers also fail.</p>
<p>My hope is also that the open-source nature of Juju and charming means that it's well suited to a world where genAI has trained on publicly accessible data, and so should 'know' a lot more than APIs and tools that are hidden away. Developing charms as open-source also avoids some of the issues around confidential or proprietary code being send off to the AI servers - I'm less inclined to repeat this experience with an entirely local model as a result.</p>
<h2>Initial experiments</h2>
<h3>Setup</h3>
<p>I created a <code>CLAUDE.md</code> file, and <code>.claude/settings.json</code>, and a few commands in <code>.claude/commands</code>. These were partially based on previous experience, partly on a small amount of research, and partly just the general longer explanation I'd give to someone writing a charm for the first time. My goal was to have a starting point, which can be improved iteratively. I deliberately did not include any mention of delta or holistic charming, or a reconcile approach (although I did provide access to the Ops documentation, where those are mentioned) - I'm curious whether genAI ends up heading the same way as charmers do.</p>
<p>I chose <a href="https://mosquitto.org/">Mosquitto</a> as a simple (but not trivial) workload to charm. My expectation is that this would be a machine charm, which I think is probably simpler to start with than a Kubernetes one (no need to build a Rock, no need to handle the Pebble events that happen at unpredictable times), although as development continues there are challenges that are easier to solve with a K8s charm (like having health checks). It should be easy enough to test a MQTT broker charm without needing a lot of additional apps.</p>
<p>I've put <a href="https://github.com/tonyandrewmeyer/charming-with-claude">my starting files in git</a> if you'd like to see the current state (or suggest improvements). I copied these to an otherwise-empty directory as the starting point for Claude (so the version at the time is also in the mosquitto-operator repository).</p>
<h3>Attempt 1 (quite flawed)</h3>
<p>You can see the <a href="https://github.com/tonyandrewmeyer/mosquitto-operator/tree/claude-attempt-1">first attempt in the claude-attempt-1 branch</a>. This also includes the <a href="https://github.com/tonyandrewmeyer/mosquitto-operator/blob/claude-attempt-1/2025-08-02-lets-build-a-charm-for-mosquitto-httpsmosquit.txt">transcript with Claude</a>.</p>
<p>I didn't set up Claude for success here: I was using macOS, and it's much better to use Ubuntu. I've used <code>uvx charmcraft</code> on that system before, but for some reason it wasn't working for Claude (I didn't look into why) so there was a bit of fluffing about trying to fix that, and then Claude gave up and started from scratch. I also didn't make Juju available at all, so it wasn't possible to run the integration tests.</p>
<p>I also made a few mistakes (like calling <code>charmcraft analyse</code> <code>charmcraft lint</code>) in the instructions, including invalid JSON for <code>settings.json</code> (a trailing comma: I hate that JSON doesn't handle that), which Claude called out but I missed (also for the next attempt).</p>
<p>The good:</p>
<ul>
<li>It's incredibly fast (whether or not fast junk is good is a separate question).</li>
<li><code>charmcraft.yaml</code> is pretty reasonable, particularly considering that <code>charmcraft init</code> wasn't available. It's not perfect ("assumes: juju" needs a version, for example, and the "parts" section isn't what it should be), but not terrible.</li>
<li>The Scenario unit tests aren't too bad, except that Claude couldn't figure out how to assert after running an action. The workload unit tests also seem ok, although I didn't look at them in a lot of detail. For Scenario, I suspect that there's more training data for Scenario v6 and older than Scenario 7, so the API changes aren't 'known' to Claude. The agent doesn't seem very good at reading API documentation, even though I've provided all the links that should be needed.</li>
<li>The <code>src/mosquitto.py</code> module is reasonable. It uses <code>apt</code> and <code>systemd</code> using <code>subprocess</code> rather than the <code>operator-libs-linux</code> charm lib, but I hadn't provided any information about charm libs, so that's understandable (if I was writing my first charm, I wouldn't assume that there was a lib for those either).</li>
<li>The <code>src/charm.py</code> module is quite good, I think, particularly considering that there was no template provided by <code>charmcraft init</code>.</li>
<li>The "research" seemed reasonable. <em>However</em>, I have no idea whether this was actually using the data found on the Mosquitto website or whether Claude already knows a heap about Mosquitto from the base training set.</li>
<li>There's a <code>provides</code> relation that would let another charm integrate with this one and get details for using Mosquitto over a <code>mqtt</code> interface. This is simplistic, but integrating is the greatest strength of Juju, so it's nice to see something along these lines. It's missing the <code>optional</code> field that I told it to always include, though.</li>
</ul>
<p>The bad:
* There was no running any of the formatting or linting or tests before writing code, as instructed.
* The integration tests are terrible. Claude started writing pytest-operator/python-libjuju tests even though I'd said to not do that, and when I interrupted to say that Jubilant should be used instead it ended up being a weird async imagined version of Jubilant.
* There's a bunch of code style that I really dislike, even though I specifically advise against it in <code>CLAUDE.md</code> (because I see genAI producing it all the time). Imports scattered all over the place, huge chunks of code in try/except blocks, catching <code>Exception</code>, excessive comments, and so on.
* Even though I'd provided guidance in <code>CLAUDE.md</code>, I had to prompt a couple of extra times to get Claude to create all the initial files and then start work on the tests.
* I emphasised in the initial instructions that the integration tests should be written first, then the code, and then the unit tests. I feel like this is a good approach for the agent, so that the charmer can verify the intended behaviour before it's written, and then the agent has a way to check that the behaviour is what was required. However, this was completely ignored (and then Claude 'lied' twice saying that it had followed this approach).
* There's some <code>requires</code> relations, but they aren't implemented. For TLS, there's the common agent pattern where it adds a "TODO" comment and returns something hard-coded.</p>
<p>Other interesting points:</p>
<ul>
<li>One of my instructions in <code>CLAUDE.md</code> was that there should be a code of conduct file. It seems like Claude is blocked from doing this -- maybe the one that I use as a base is specifically blocked, but it seems like it's just blocked in general. This is pretty odd, but also easily worked around.</li>
<li>The <code>src/charm.py</code> has a bunch of older style approaches, like <code>*args</code> in <code>__init__</code>, <code>self.framework.observe</code> rather than just <code>framework.observe</code>, and so on. I assume this is a result of older training data, and it's an interesting question how to work around this - we don't want to be stuck in our ways just because genAI tends to produce more of the same.</li>
</ul>
<p>Overall, not completely awful, but I think I would rather start from scratch than start from this, and it doesn't actually work, so couldn't be used as a proof-of-concept or prototype without more work.</p>
<h3>Attempt 2 (more interesting)</h3>
<p>You can see the <a href="https://github.com/tonyandrewmeyer/mosquitto-operator/tree/claude-attempt-2">second attempt in the claude-attempt-2 branch</a>. This also includes the <a href="https://github.com/tonyandrewmeyer/mosquitto-operator/blob/claude-attempt-2/2025-08-04-lets-develop-a-charm-for-mosquitto-httpsmosqu.txt">transcript with Claude</a> (continued in <a href="https://github.com/tonyandrewmeyer/mosquitto-operator/blob/claude-attempt-2/2025-08-04-this-session-is-being-continued-from-a-previous-co-1.txt">part 2</a> and <a href="https://github.com/tonyandrewmeyer/mosquitto-operator/blob/claude-attempt-2/2025-08-04-this-session-is-being-continued-from-a-previous-co-2.txt">part3</a>). Claude was better at committing as it progressed in this attempt, and I interacted a little more, so you can also review the separate commits to see how things progressed. I also committed the <code>settings.local.json</code> file, which you normally should not, so you can see what I approved (if I hadn't messed up <code>settings.json</code> this would have been smaller).</p>
<p>I provided a better setup here: I created a fresh Multipass VM using the (soon to be discontinued :() <code>charm-dev</code> blueprint, native mounted the empty (other than the starting Claude files) repository directory in there, and ran Claude inside it. This meant that <code>charmcraft</code>, <code>juju</code> and other charming tools were all available. The Multipass environment meant that I was willing to let Claude run almost any command since I could just throw away the VM at the end.</p>
<p>(I hit the usage limit early on, but that wouldn't have been because of these two attempts - Claude had been doing some other (non-charming) things for me elsewhere at the same time. I continued for a bit later in the day after it reset. The second time I hit the limit was predominately this experimentation - I have a <a href="https://www.anthropic.com/pricing">Pro</a> account and was using the default model, Sonnet 4.)</p>
<p>The good:
* The scaffolding provided by <code>charmcraft init</code> seemed to help a lot, as expected.
* It's a reasonable start at documentation. No-one tell Daniele that I did this ;) (Obviously, you'd want to have a human go through and improve this). However, there are links to how-to and explanation and reference files that simply don't exist, and some of the (theoretical) documentation is probably (hard to tell without being able to read it!) too focused on the workload rather than the charm.
* The logo is nice enough. For anything I was serious about, I would commission a human artist, but since this is an experiment with agents, it seems fair to let it generate one.
* The README is quite good, although far too long. It's interesting that it assumed the repo was in the <code>canonical</code> organisation, even though that information is available with <code>git remote</code>.
* Adding tracing worked reasonably well, except that it added far too many spans that just duplicate Ops ones, even though I gave advice against that. There are also way too many events, many of which are just "span started" and "span finished".</p>
<p>The bad:
* The charm wasn't able to be successfully deployed. (Originally: I did get it working by the end.)
* The integration tests look like reasonable Jubilant code at first glance, but when you look closer, it's more like it's an imagining of what Jubilant might be based on some understanding of (dated) Juju CLI commands. I don't think there was any use of the Jubilant docs, and, because Jubilant is new, there would probably be no examples in the Claude training data.
* Even though I had added instructions on how to use <code>operator-libs-linux</code> into <code>CLAUDE.md</code> the <code>src/mosquitto.py</code> module still uses plain <code>subprocess</code> calls. (I helped a bit with this when those subprocess calls were causing issues later on.)
* There's no use of <code>storage</code> like in the first attempt (until I prompted for improvement).
* There are no relations like in the first attempt (until I prompted for improvement).
* In the unit tests, there's the common AI agent pattern of "don't really test, just write a not about properly testing later" for all the actions. This is probably better than made-up test code like with the first attempt, but still not great. This also shows up how coverage is not a great metric (but is one that Claude really 'likes'): you can get all the coverage by running the action and yet not asserting anything about what it did.
* genAI has an annoying tendency to talk itself up (and also be overly complementary of the user). It's like it was trained on material that was going to a presentation for executives that don't know very much about code but recognise buzzwords... - this shows up in the "architecture" and "infrastructure" notes that were added, as well as the changelog.
* Several diagrams aren't valid Mermaid so don't render, and a lot of them seem way too complicated to actually be useful.</p>
<p>Interesting notes:
* Even Claude finds <code>charmcraft pack</code> far too slow (it gave up waiting). Subsequent runs are generally faster, so this might solve itself if you do an initial pack for Claude, but maybe there's a way to tell it to wait longer.
* The integration tests are also too slow for Claude to properly use them (part of this is probably packing).
* The code of conduct creation failed in the same way at the previous attempt.
* A pattern I saw here, which I've seen before with Claude, is that if something doesn't work (like linting finds issues with a file) then it'll just throw that away and try a completely different approach rather than just fixing the problems.</p>
<p>I feel like the scaffolding that <code>charmcraft init</code> provides is extremely important when using an AI agent. Not only does it provide some of the boilerplate (like the tox setup) that should be done in a very specific way, it provides examples of how observing events should be done, how unit and integration tests should be done, and that's quite significant in improving what the agent then produces. For example, I think that when we update the Charmcraft profiles to use Jubilant for tests, an AI agent will do a much better job of writing more of those than it does at the moment having to rip out the existing ones and start from scratch.</p>
<p>Speed is clearly important when using AI agents. It's great that we can use <code>ruff</code> and I think we should move as quickly as we can to use <code>ty</code> rather than <code>pyright</code> or <code>mypy</code>. We should continue to improve the speed of running Scenario unit tests, and see what we can do to make the integration tests (and packing!) faster, not only in CI but also on local systems.</p>
<h2>Next</h2>
<p>I'd love to hear from anyone else that has done similar experimenting - what worked well, what didn't, what scaffolding did you provide, which agent did you use, what differed from my experience, and so on.</p>
<p>If I have some time next weekend, I'll do a third attempt for Mosquitto, updating the setup based on what I've learnt here. I might provide a tweaked <code>charmcraft init</code> that uses Jubilant, uses the <code>uv</code> plug-in for the charm, and a few other similar improvements that we know are coming in time. Maybe also the tooling for creating the <code>charmcraft.yaml</code> action and config blocks based on Python classes in the code -- it seems like that would be useful, so that the AI agent only needs to know how to write a Python class and can then get exactly correct and matching Charmcraft YAML using a tool. Perhaps also recommending <a href="https://pypi.org/project/pytest-jubilant/">pytest-jubilant</a> over plain Jubilant.</p>
<p>Speed is the biggest issue at the moment (in terms of not being able to pack and therefore do any real tests), but maybe providing it with instructions on using jhack to avoid the pack and deploy delays will solve that.</p>
<p>I might also try a different charm, to see how much it differs - perhaps one that I'd expect to be a Kubernetes charm. If anyone has any suggestions, I'm happy to hear them!</p>]]></content:encoded>
      <dc:creator>Tony Meyer</dc:creator>
      <pubDate>Tue, 23 Dec 2025 14:08:47 +1300</pubDate>
      <guid isPermaLink="false">experiment-2025-08-01-mosquitto-operator</guid>
    </item>
    <item>
      <title>Reading List Update: Update READTHEM.md</title>
      <link>https://github.com/tonyandrewmeyer/charming-with-claude/commit/b54cec7d150659586375315c038520d3f71c67a0</link>
      <description>Update READTHEM.md</description>
      <content:encoded><![CDATA[<pre>diff --git a/READTHEM.md b/READTHEM.md
index 13b3741..986b171 100644
--- a/READTHEM.md
+++ b/READTHEM.md
@@ -17,7 +17,7 @@
 * [You Should Write An Agent](https://fly.io/blog/everyone-write-an-agent/) - on the fly.io blog but not at all specific to their services
 * [Built With Borrowed Hands](https://cra.mr/built-with-borrowed-hands/) - building Sentry&apos;s MCP server
 * [Safe YOLO mode for Claude](https://www.anthropic.com/engineering/claude-code-best-practices#d-safe-yolo-mode) - the Docker Dev Containers example in particular
-* [LLMs as Parts of Systems](https://brooker.co.za/blog/2025/08/12/llms-as-components.html) - from one of the Kiro engineers
+* [LLMs as Parts of Systems](https://brooker.co.za/blog/2025/08/12/llms-as-components.html) - from one of the [Kiro](https://kiro.dev/) engineers
 * [The fate of “small” open source](https://nolanlawson.com/2025/11/16/the-fate-of-small-open-source/) - the author argues that there is educational value in the zillion tiny library issue, which AI may solve
 * [Just Talk To It - the no-bs Way of Agentic Engineering](https://steipete.me/posts/just-talk-to-it) - Will date quickly, but a good summary of the world in October 2025
 * [A pragmatic guide to LLM evals for devs](https://newsletter.pragmaticengineer.com/p/evals)
</pre>]]></content:encoded>
      <dc:creator>Tony Meyer</dc:creator>
      <pubDate>Tue, 23 Dec 2025 10:18:11 +1300</pubDate>
      <guid isPermaLink="false">readthem-b54cec7d150659586375315c038520d3f71c67a0</guid>
    </item>
    <item>
      <title>Reading List Update: docs: Add a list of reading material.</title>
      <link>https://github.com/tonyandrewmeyer/charming-with-claude/commit/a96500c3aeedf904de8672ce1048f02282194fb1</link>
      <description>docs: Add a list of reading material.</description>
      <content:encoded><![CDATA[<pre>diff --git a/READTHEM.md b/READTHEM.md
new file mode 100644
index 0000000..13b3741
--- /dev/null
+++ b/READTHEM.md
@@ -0,0 +1,23 @@
+# AI Reading
+
+## Read everything from
+
+* [Ed Zitron&apos;s Where&apos;s Your Ed At](https://www.wheresyoured.at/). Primarily focused on the economic aspects. Very long articles. Generally negative.
+* [Simon Willison&apos;s blog](https://simonwillison.net). Quite practical. Author of the [Python llm tool](https://llm.datasette.io/en/stable/) (also Django, datasette). Generally positive.
+* [Armin Ronacher&apos;s Thoughts and Writings (on AI)](https://lucumr.pocoo.org/tags/ai/). Mostly positive. Technical and practical.
+* [Wil McGugan&apos;s Essays](https://willmcgugan.github.io/categories/#toad). Developing a new terminal coding agent, [Toad](https://github.com/batrachianai/toad). The future may be Python, not JavaScript!
+* [MIT AI Risk Initiative](https://airisk.mit.edu/ai-incident-tracker) - fewer articles, but lots of data
+
+## Read these specific articles
+
+* [Your job is to deliver code you have proven to work](https://simonwillison.net/2025/Dec/18/code-proven-to-work/).
+* [How to write a great agents.md: Lessons from over 2,500 repositories](https://github.blog/ai-and-ml/github-copilot/how-to-write-a-great-agents-md-lessons-from-over-2500-repositories/) - GitHub blog
+* [Introducing nanochat: The best ChatGPT that $100 can buy.](https://github.com/karpathy/nanochat/discussions/1) - a walkthrough of training a model at $24/hour.
+* [How I Use Every Claude Code Feature](https://blog.sshh.io/p/how-i-use-every-claude-code-feature)
+* [You Should Write An Agent](https://fly.io/blog/everyone-write-an-agent/) - on the fly.io blog but not at all specific to their services
+* [Built With Borrowed Hands](https://cra.mr/built-with-borrowed-hands/) - building Sentry&apos;s MCP server
+* [Safe YOLO mode for Claude](https://www.anthropic.com/engineering/claude-code-best-practices#d-safe-yolo-mode) - the Docker Dev Containers example in particular
+* [LLMs as Parts of Systems](https://brooker.co.za/blog/2025/08/12/llms-as-components.html) - from one of the Kiro engineers
+* [The fate of “small” open source](https://nolanlawson.com/2025/11/16/the-fate-of-small-open-source/) - the author argues that there is educational value in the zillion tiny library issue, which AI may solve
+* [Just Talk To It - the no-bs Way of Agentic Engineering](https://steipete.me/posts/just-talk-to-it) - Will date quickly, but a good summary of the world in October 2025
+* [A pragmatic guide to LLM evals for devs](https://newsletter.pragmaticengineer.com/p/evals)
</pre>]]></content:encoded>
      <dc:creator>Tony Meyer</dc:creator>
      <pubDate>Tue, 23 Dec 2025 10:14:17 +1300</pubDate>
      <guid isPermaLink="false">readthem-a96500c3aeedf904de8672ce1048f02282194fb1</guid>
    </item>
  </channel>
</rss>